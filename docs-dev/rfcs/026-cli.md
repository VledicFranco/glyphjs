# RFC-026: CLI Tool for Rendering and Exporting

- **Status:** Draft
- **Issue:** [#76](https://github.com/VledicFranco/glyphjs/issues/76)
- **Related:** `packages/compiler`, `packages/runtime`, `packages/components`

---

## 1. Problem

GlyphJS documents can only be viewed in a web browser via a running application. This creates friction for:

1. **Document sharing** — Authors can't send polished documents to colleagues who don't have access to a glyphjs-powered site
2. **Offline viewing** — No way to export a self-contained artifact
3. **Integration with other tools** — No path to Google Docs, Word, Confluence, etc.
4. **CI/CD pipelines** — No automated documentation generation

A CLI tool bridges this gap by enabling `markdown → rendered output` without a browser-based app.

---

## 2. Design Principles

1. **Leverage existing packages.** The CLI is a thin orchestration layer over `@glyphjs/compiler`, `@glyphjs/runtime`, and `@glyphjs/components`. It does not reimplement any rendering logic.

2. **Progressive capability.** The simplest command (`compile`) requires no browser or external binary dependencies. More capable commands (`render`, `export`) pull in Playwright or Pandoc only when used.

3. **Deterministic output.** Same input, same options → same output. No timestamps or random IDs in generated files unless explicitly requested.

4. **Composable.** Each command does one thing. `compile` produces IR JSON. `render` produces images. `export` produces documents. They can be chained via stdout/stdin or file paths.

5. **Familiar UX.** Follows CLI conventions: `--output` / `-o` for output path, `--format` / `-f` for format selection, `--verbose` / `-v` for diagnostics, exit codes for success/failure.

---

## 3. Package Design

### 3.1 New package: `@glyphjs/cli`

Location: `packages/cli/`

```
packages/cli/
├── src/
│   ├── index.ts              # Entry point, commander setup
│   ├── commands/
│   │   ├── compile.ts        # markdown → IR JSON
│   │   ├── render.ts         # blocks → images (Playwright)
│   │   ├── export.ts         # documents → HTML/PDF/DOCX/MD
│   │   └── serve.ts          # dev server with watch
│   ├── rendering/
│   │   ├── browser.ts        # Playwright browser lifecycle
│   │   ├── html-template.ts  # HTML shell for SSR + hydration
│   │   ├── screenshot.ts     # Block → image capture
│   │   └── ssr.tsx           # React SSR helpers (renderToString)
│   ├── export/
│   │   ├── html.ts           # Self-contained HTML bundling
│   │   ├── pdf.ts            # Playwright page.pdf()
│   │   ├── docx.ts           # Pandoc conversion
│   │   └── markdown.ts       # Markdown with rendered image refs
│   └── utils/
│       ├── logger.ts         # Structured output (diagnostics, progress)
│       └── resolve.ts        # File path resolution, glob expansion
├── templates/
│   └── document.html         # HTML shell template
├── package.json
├── tsconfig.json
└── tsup.config.ts
```

### 3.2 Dependencies

```json
{
  "name": "@glyphjs/cli",
  "version": "0.6.0",
  "type": "module",
  "bin": {
    "glyphjs": "./dist/index.js"
  },
  "dependencies": {
    "@glyphjs/types": "workspace:*",
    "@glyphjs/compiler": "workspace:*",
    "@glyphjs/runtime": "workspace:*",
    "@glyphjs/components": "workspace:*",
    "commander": "^13.0.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "optionalDependencies": {
    "playwright": "^1.58.0"
  }
}
```

**Key decisions:**

- **React is a direct dependency**, not a peer dep. The CLI is an end-user tool, not a library — it must work out of the box.
- **Playwright is an optional dependency.** The `compile` command works without it. The `render` and `export` commands check for Playwright at runtime and print a helpful install message if missing.
- **Pandoc is an external binary.** Checked at runtime for `export --format docx` only.

### 3.3 CLI argument parser

**Commander.js** — lightweight, well-maintained, supports subcommands, auto-generates help text.

---

## 4. Commands

### 4.1 `glyphjs compile`

Compile markdown to IR JSON. No browser or external binary dependencies — only the compiler pipeline (unified/remark/zod). This is the "always works" baseline.

```bash
# Compile to stdout
glyphjs compile doc.md

# Compile to file
glyphjs compile doc.md -o doc.ir.json

# Compile with diagnostics on stderr
glyphjs compile doc.md --verbose

# Read from stdin
cat doc.md | glyphjs compile -

# Pretty-print (default) vs compact
glyphjs compile doc.md --compact
```

**Implementation:** Read file → `compile(markdown, { filePath })` → write `JSON.stringify(result.ir)` to stdout or file. Passing `filePath` enables the compiler to generate stable document IDs from the source path. Diagnostics go to stderr.

**Exit codes:**
- `0` — Success (may have warnings)
- `1` — Compilation errors (IR still produced, written to output)
- `2` — Fatal error (file not found, invalid input)

### 4.2 `glyphjs render`

Render UI blocks to images using Playwright headless browser.

```bash
# Render all ui: blocks to PNG files
glyphjs render doc.md --output-dir ./images/

# Render a specific block by glyph-id
glyphjs render doc.md --block-id "architecture-diagram" -o arch.png

# Options
--format png|jpeg      # Output format (default: png)
--scale 2              # Device scale factor (default: 2)
--width 800            # Viewport width in px (default: 800)
--theme light|dark     # Theme (default: light)
--timeout 30000        # Per-block render timeout in ms (default: 30000)
```

**Pipeline:**

1. `compile(markdown, { filePath })` → IR
2. Filter blocks: only `ui:*` typed blocks (skip headings, paragraphs, etc.)
3. Launch Playwright Chromium (reuse single browser instance for all blocks)
4. For each block:
   a. Build minimal HTML page with React SSR of that single block + client JS bundle for hydration
   b. Load page in Playwright
   c. Wait for render completion using the multi-stage strategy (see Section 5.4)
   d. Screenshot the `.glyph-block` element
   e. Write to `{output-dir}/{block-id}.{format}` or specified `-o` path
5. Close browser

**Output naming:** `{block.id}.png` by default. If a block has a `glyph-id`, use that. Otherwise use the content-addressed ID from the IR.

**Browser lifecycle:** Single `browser.launch()` per invocation, new `page` per block. The browser is the expensive part — amortize it.

### 4.3 `glyphjs export`

Export complete documents to various formats.

```bash
# Self-contained HTML
glyphjs export doc.md --format html -o doc.html

# PDF via Playwright
glyphjs export doc.md --format pdf -o doc.pdf

# DOCX via Pandoc
glyphjs export doc.md --format docx -o doc.docx

# Markdown with rendered images
glyphjs export doc.md --format md -o doc-rendered.md --images-dir ./images/

# Common options
--theme light|dark     # Theme (default: light)
--width 800            # Page/viewport width (default: 800)
--title "My Document"  # Override document title
```

**Format-specific details:**

#### HTML (self-contained)

1. Compile markdown → IR
2. React SSR: `renderToString(createElement(GlyphDocument, { ir }))`
3. Inject theme CSS variables into a `<style>` tag (no component CSS extraction needed — all styles are inline)
4. Write single `.html` file — works offline, no external requests

**SSR limitation:** Components using D3 (Chart, Graph, Architecture) render their visuals in `useEffect`, which does not run during `renderToString`. In SSR-only mode, these will show empty containers or SSR placeholders. Simple components (Callout, Table, Steps, Tabs, Timeline, etc.) render fully.

For documents heavy on D3 components, users should use `export --format pdf` (Phase 3) which renders via Playwright and captures the full output, or `render` to get per-block images. A future enhancement (SSR + hydration with inlined client JS) could make HTML export render D3 components fully — see Section 9.

#### PDF

1. Compile markdown → IR
2. Build full HTML page with SSR + client JS bundle (React + components)
3. Load in Playwright, wait for full render completion (including D3 effects — see Section 5.4)
4. `page.pdf({ format: 'A4', printBackground: true })`
5. Write to output path

Unlike HTML SSR-only export, PDF uses Playwright to render the page — so D3-based components (Chart, Graph, Architecture) render fully. This produces the highest-fidelity output.

#### DOCX

1. Run `render` pipeline to generate images for all `ui:*` blocks
2. Build processed markdown: replace `ui:*` fenced code blocks with `![block-id](images/block-id.png)` image references
3. Run `pandoc processed.md -o output.docx` with appropriate flags
4. Clean up temp files

DOCX is inherently lossy — interactive components become static images. This is acceptable for the Google Docs / Word / Confluence use case.

**Pandoc requirement:** The CLI checks for `pandoc` on `$PATH`. If missing, prints:

```
Error: DOCX export requires Pandoc.
Install it from https://pandoc.org/installing.html
```

#### Markdown (rendered)

1. Run `render` pipeline to generate images for all `ui:*` blocks
2. Replace fenced code blocks with image references
3. Write processed markdown + images directory

Useful for embedding in GitHub READMEs, static site generators, or anywhere that supports standard Markdown with images.

### 4.4 `glyphjs serve` (Phase 5)

Development server with live reload.

```bash
glyphjs serve doc.md --port 3000

# Options
--port 3000            # Port (default: 3000)
--theme light|dark     # Theme (default: light)
--open                 # Open browser on start
```

**Implementation:** Minimal Node HTTP server + `fs.watch` + WebSocket:

1. Reads markdown file, compiles, renders to HTML
2. Serves the HTML page with an injected WebSocket client
3. Watches file for changes via `fs.watch`
4. On change: re-compiles, pushes new IR over WebSocket, client re-renders

This is the lowest priority — authors can already use `apps/demo` for development. The value is convenience for standalone documents. We intentionally avoid Vite to keep the CLI dependency footprint lean.

---

## 5. Rendering Architecture

### 5.1 HTML template

The CLI needs an HTML shell to render React components in Playwright. This template is used by both `render` and `export`:

```html
<!DOCTYPE html>
<html lang="en" data-theme="{{theme}}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale={{scale}}">
  <title>{{title}}</title>
  <style>
    /* Reset */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, sans-serif; }
    /* Theme variables (CSS custom properties) */
    :root { {{themeCSS}} }
  </style>
</head>
<body>
  <div id="root">{{ssrHTML}}</div>
  <script type="module">
    {{clientBundle}}
  </script>
</body>
</html>
```

**Note on component styles:** All GlyphJS components use inline styles with CSS custom property references (e.g. `var(--glyph-callout-info-bg)`). There are no external CSS files, CSS modules, or CSS-in-JS to extract. The only CSS the template needs is the `:root` block defining the theme variable values.

### 5.2 SSR strategy

The CLI source files that call `renderToString` with JSX will need to be `.tsx` files (compiled by tsup with JSX support).

**Component registration:** The `@glyphjs/components` package exports each definition individually (e.g. `calloutDefinition`, `chartDefinition`). There is no barrel array. As a prerequisite (see Section 6, Prerequisites), we add an `allComponentDefinitions` export to `@glyphjs/components`.

For the `render` command (block → image), we render individual blocks:

```tsx
// packages/cli/src/rendering/ssr.tsx
import { renderToString } from 'react-dom/server';
import { createElement } from 'react';
import { createGlyphRuntime } from '@glyphjs/runtime';
import { allComponentDefinitions } from '@glyphjs/components';
import type { Block, GlyphIR } from '@glyphjs/types';

function renderBlockToHTML(block: Block, theme: 'light' | 'dark'): string {
  const runtime = createGlyphRuntime({
    components: allComponentDefinitions,
    theme,
  });
  const { GlyphDocument } = runtime;
  // Create a minimal IR with just this block
  const ir: GlyphIR = {
    version: '1.0',
    id: 'cli-render',
    metadata: {},
    blocks: [block],
    references: [],
    layout: { mode: 'document' },
  };
  return renderToString(createElement(GlyphDocument, { ir }));
}
```

For the `export --format html` command, we render the full document:

```tsx
function renderDocumentToHTML(ir: GlyphIR, theme: 'light' | 'dark'): string {
  const runtime = createGlyphRuntime({
    components: allComponentDefinitions,
    theme,
  });
  const { GlyphDocument } = runtime;
  return renderToString(createElement(GlyphDocument, { ir }));
}
```

### 5.3 Playwright browser management

Lazy singleton — one browser instance per CLI invocation, one page per block render. The browser is the expensive part (~1-2s launch); pages are cheap (~50ms).

```typescript
import { chromium, type Browser, type Page } from 'playwright';

class BrowserManager {
  private browser: Browser | null = null;

  async newPage(): Promise<Page> {
    if (!this.browser) {
      this.browser = await chromium.launch({ headless: true });
    }
    return this.browser.newPage();
  }

  async closePage(page: Page): Promise<void> {
    await page.close();
  }

  async shutdown(): Promise<void> {
    await this.browser?.close();
    this.browser = null;
  }
}
```

### 5.4 Render completion detection

Components like Chart, Graph, and Architecture render asynchronously — they use D3 inside `useEffect` hooks and ELK for async layout computation. `DOMContentLoaded` fires before React effects run, so it is **not** a reliable signal.

**Approach:** A multi-stage wait strategy:

1. **`page.waitForLoadState('domcontentloaded')`** — baseline: HTML is parsed.
2. **`page.waitForSelector('[data-glyph-block]')`** — React has mounted and rendered the block container.
3. **`page.waitForFunction(() => !document.querySelector('[data-glyph-loading]'))`** — Components that perform async work (ELK layout, D3 transitions) set a `data-glyph-loading` attribute while in progress and remove it when done. This is a **new convention** that must be added to async components as a prerequisite.
4. **Stability check** — After the above signals pass, take two screenshots 200ms apart and compare dimensions. If the layout shifted (e.g. a late ELK callback), wait and retry.
5. **`--timeout` (default 30s)** — hard ceiling per block. If exceeded, screenshot whatever is on screen and log a warning.

**Prerequisite:** Async components (Chart, Graph, Architecture) must adopt the `data-glyph-loading` attribute convention. This is a small change — set the attribute on mount, remove it when the D3/ELK render callback fires. See Section 6, Prerequisites.

---

## 6. Implementation Phases

### Phase 0: Package scaffolding + `compile` command

**Scope:** Create the package, wire into monorepo, implement the simplest command.

**Files:**

- `packages/cli/package.json`
- `packages/cli/tsconfig.json`
- `packages/cli/tsup.config.ts`
- `packages/cli/src/index.ts` — commander setup, `compile` subcommand
- `packages/cli/src/commands/compile.ts` — read file, `compile()`, write JSON
- `packages/cli/src/utils/logger.ts` — diagnostic formatting
- `pnpm-workspace.yaml` — already covers `packages/*`
- `turbo.json` — no changes needed (existing `build` task covers it)

**Dependencies:** `@glyphjs/compiler`, `commander`

**Test:** `echo '# Hello' | glyphjs compile -` outputs valid IR JSON.

**Milestone:** Publishable as `@glyphjs/cli@0.6.0` (aligned with other package versions).

### Prerequisites (before Phase 1)

Phase 0 has no prerequisites — it only depends on `@glyphjs/compiler`. Before starting Phase 1, the following changes to existing packages are required:

1. **Export theme variable maps from `@glyphjs/runtime`.**
   Move `LIGHT_THEME_VARS` and `DARK_THEME_VARS` from `packages/components/.storybook/preview.ts` to `packages/runtime/src/themes/variables.ts`. Export them and a `themeVarsToCSS()` helper. Update the Storybook preview to import from `@glyphjs/runtime`. (See Section 7.2.)

2. **Add `allComponentDefinitions` barrel export to `@glyphjs/components`.**
   Add to `packages/components/src/index.ts`:
   ```typescript
   export const allComponentDefinitions: GlyphComponentDefinition[] = [
     calloutDefinition,
     chartDefinition,
     // ... all definitions
   ];
   ```
   This avoids the CLI maintaining a fragile manual list that breaks when components are added.

3. **Add `data-glyph-loading` convention to async components.**
   Components that perform async rendering (Chart, Graph, Architecture) should set `data-glyph-loading="true"` on their container during async work (D3 rendering, ELK layout) and remove it when done. This gives the CLI a reliable signal for screenshot timing. (See Section 5.4.)

### Phase 1: `render` command (blocks → images)

**Scope:** Headless browser rendering of individual `ui:*` blocks to PNG/JPEG.

**Files:**

- `packages/cli/src/commands/render.ts`
- `packages/cli/src/rendering/browser.ts` — Playwright lifecycle (`BrowserManager`)
- `packages/cli/src/rendering/html-template.ts` — HTML shell builder with theme variable injection
- `packages/cli/src/rendering/screenshot.ts` — block → image capture logic
- `packages/cli/src/rendering/ssr.tsx` — React SSR helpers

**Dependencies add:** `playwright` (optional), `react`, `react-dom`, `@glyphjs/runtime`, `@glyphjs/components`

**Key challenges:**

- Async render detection: D3-based components (Chart, Graph, Architecture) render in `useEffect`, not during SSR. The page must hydrate and run effects before screenshotting. Depends on the `data-glyph-loading` convention (see Section 5.4).
- Font loading: Playwright's bundled Chromium may not have all system fonts. May need `--font-path` option or documentation on font availability.

**Test:** `glyphjs render fixtures/architecture.md --output-dir ./out/` produces a PNG for each `ui:` block.

### Phase 2: `export --format html` (self-contained HTML)

**Scope:** Full-document React SSR bundled into a single HTML file.

**Files:**

- `packages/cli/src/commands/export.ts` — format dispatch
- `packages/cli/src/export/html.ts` — SSR + inline bundling

**Key challenges:**

- D3-based components (Chart, Graph, Architecture) render via `useEffect`, which does not run in `renderToString`. In SSR-only mode, these will show empty containers or SSR placeholders. Options:
  - **SSR-only (no JS):** Static HTML. Simple components (Callout, Table, Steps, Tabs) render fully. D3 components show placeholders. Simpler, smaller output.
  - **SSR + hydration:** Bundle React + components inline. D3 components render fully. Larger output (~200KB+ gzipped).
- Recommend starting with SSR-only. Full hydration can be a follow-up. For documents heavy on D3 components, users can use `export --format pdf` (Phase 3) which renders via Playwright and captures the full output.

**Test:** `glyphjs export fixtures/full-doc.md --format html -o out.html` produces a self-contained HTML file that opens correctly in a browser.

### Phase 3: `export --format pdf`

**Scope:** PDF generation via Playwright's `page.pdf()`.

**Files:**

- `packages/cli/src/export/pdf.ts`

**Implementation:** Build full HTML with SSR + client JS bundle (same template as render), load in Playwright, wait for full render (Section 5.4), then call `page.pdf()`. Reuses the browser management (Phase 1) and HTML template infrastructure (Phase 2).

**Options:**

```bash
--page-size A4|letter|legal    # Page size (default: A4)
--margin "1in"                 # Page margins
--landscape                    # Landscape orientation
```

**Test:** `glyphjs export fixtures/full-doc.md --format pdf -o out.pdf` produces a valid PDF.

### Phase 4: `export --format docx` and `export --format md`

**Scope:** DOCX via Pandoc, Markdown with rendered images.

**Files:**

- `packages/cli/src/export/docx.ts` — Pandoc wrapper
- `packages/cli/src/export/markdown.ts` — block replacement with image refs

**Pipeline (DOCX):**

1. Run Phase 1 render pipeline → images for all `ui:*` blocks
2. Rewrite markdown: replace fenced code blocks with `![](images/block-id.png)`
3. Shell out to `pandoc --from=markdown --to=docx`
4. Clean up temp directory

**Pipeline (Markdown):**

1. Same as steps 1-2 above
2. Write processed markdown + images directory

**Test:** Pandoc installed → `glyphjs export doc.md --format docx -o doc.docx` produces a valid DOCX. Pandoc missing → clear error message with install link.

### Phase 5: `serve` command

**Scope:** Dev server with live reload for authoring.

**Files:**

- `packages/cli/src/commands/serve.ts`

**Implementation:** Minimal Node HTTP server + `fs.watch` + WebSocket (see Section 4.4). No framework dependencies (Vite, Express) — the CLI should stay lean.

**Test:** `glyphjs serve doc.md` starts a server, editing the file triggers browser reload.

---

## 7. Theme and Style Handling

### 7.1 Component styles

All GlyphJS components use **inline styles** with CSS custom property references. Example from `Callout.tsx`:

```typescript
const containerStyle: React.CSSProperties = {
  backgroundColor: `var(--glyph-callout-${type}-bg)`,
  borderLeft: `4px solid var(--glyph-callout-${type}-border)`,
  borderRadius: 'var(--glyph-radius-md, 0.1875rem)',
};
```

D3-rendered components (Chart, Graph, Architecture) apply CSS variables via D3 attribute setters:

```typescript
.attr('fill', 'var(--glyph-text, #1a2035)')
```

There are **no CSS modules, CSS-in-JS libraries, or external `.css` files** in the components package. This means:

- No CSS extraction is needed for SSR
- The only CSS the CLI must inject is the theme variable definitions (`:root { --glyph-bg: #f4f6fa; ... }`)
- All fallback values are baked into the inline styles, so components render reasonably even without theme variables — but colors will be wrong in dark mode

### 7.2 Theme variable maps

The canonical theme variable definitions live in `packages/components/.storybook/preview.ts` as `LIGHT_THEME_VARS` and `DARK_THEME_VARS` — `Record<string, string>` maps with ~105 entries each. **These are currently not exported** from any importable module; they are local constants in the Storybook config.

**Prerequisite action:** Move the theme variable maps to `packages/runtime/src/themes/variables.ts` and export them:

```typescript
// packages/runtime/src/themes/variables.ts
export const LIGHT_THEME_VARS: Record<string, string> = { ... };
export const DARK_THEME_VARS: Record<string, string> = { ... };

/** Convert a theme variable map to a CSS string for injection into :root */
export function themeVarsToCSS(vars: Record<string, string>): string {
  return Object.entries(vars).map(([k, v]) => `${k}: ${v};`).join('\n  ');
}
```

The Storybook preview would then import from `@glyphjs/runtime` instead of defining its own copy. The CLI imports the same maps. See Section 6, Prerequisites.

---

## 8. Error Handling

### 8.1 Missing optional dependencies

```
$ glyphjs render doc.md
Error: The 'render' command requires Playwright.
Run: npx playwright install chromium
```

```
$ glyphjs export doc.md --format docx
Error: DOCX export requires Pandoc.
Install from: https://pandoc.org/installing.html
```

### 8.2 Compilation diagnostics

Warnings print to stderr and don't affect exit code. Errors print to stderr and set exit code 1, but IR is still produced (matching compiler behavior).

```
$ glyphjs compile doc.md --verbose
warn [UNKNOWN_UI_COMPONENT] doc.md:15:1 — Unknown component type 'ui:foo'
error [SCHEMA_VALIDATION_FAILED] doc.md:22:1 — Missing required field 'columns' in ui:table
Compiled with 1 error and 1 warning.
```

### 8.3 Render failures

If a block fails to render (Playwright timeout, React error), the CLI:

1. Logs the error to stderr
2. Continues with remaining blocks
3. Sets exit code 1 at the end
4. Reports which blocks failed in the summary

---

## 9. Future Enhancements (out of scope)

- **Watch mode for `render`/`export`:** Re-export on file changes
- **Config file (`.glyphrc` or `glyph.config.ts`):** Default options per project
- **Batch processing:** `glyphjs export docs/*.md --format pdf --output-dir ./pdfs/`
- **Custom templates:** User-provided HTML templates for `export --format html`
- **Google Docs API integration:** Direct upload via `gdrive` or Google API
- **Interactive HTML export:** SSR + hydration for full client-side interactivity

---

## 10. Cross-Platform Considerations

The project is developed on Windows. The CLI must work on Windows, macOS, and Linux.

- **File paths:** Use `node:path` consistently. Never hardcode `/` separators. Use `path.join()` and `path.resolve()` for all path construction.
- **Temp directories:** Use `node:os` `tmpdir()` for temporary files (rendered images, processed markdown). Clean up in a `finally` block.
- **Pandoc detection:** Check `$PATH` via `which pandoc` (Unix) or `where pandoc` (Windows). Use a cross-platform helper or `execa`'s path resolution.
- **Shebang:** The `#!/usr/bin/env node` shebang in the built CLI entry point works on Unix. On Windows, npm/pnpm handle this via `.cmd` wrapper scripts automatically.
- **Playwright browsers:** `npx playwright install chromium` works cross-platform. The CLI error message for missing Playwright should include this exact command.

---

## 11. Alternatives Considered

### Puppeteer instead of Playwright (rejected)

Playwright is already a dev dependency for E2E tests. Using it for the CLI avoids adding a second browser engine. Playwright also supports `page.pdf()` natively, has better cross-platform support, and the project team already has familiarity with it.

### JS-native DOCX generation instead of Pandoc (rejected)

Libraries like `docx` (npm) can generate DOCX from JavaScript, but:

- They require manual construction of document elements (paragraphs, tables, images)
- Markdown → DOCX conversion would need to be implemented from scratch
- Pandoc handles this comprehensively with a single shell command
- The DOCX output fidelity from Pandoc is higher

Trade-off: users must install Pandoc separately. Acceptable because DOCX export is a power-user feature, and the install is straightforward on all platforms.

### Bundling as a standalone binary (deferred)

Tools like `pkg` or `bun build --compile` could produce a single executable. Deferred because:

- Playwright requires a separate Chromium binary regardless
- The Node.js ecosystem install via `npm install -g` is the expected pattern
- Can be added later without architectural changes

---

## 12. References

- Issue: [#76 — CLI tool for rendering and exporting](https://github.com/VledicFranco/glyphjs/issues/76)
- Compiler API: `packages/compiler/src/index.ts` — `compile(markdown, options?)`
- Runtime API: `packages/runtime/src/index.ts` — `createGlyphRuntime(config)`
- Component definitions: `packages/components/src/*/index.ts` — `*Definition` exports
- Theme variables: `packages/components/.storybook/preview.ts` — `LIGHT_THEME_VARS`, `DARK_THEME_VARS`
- Monorepo config: `turbo.json`, `pnpm-workspace.yaml`
